SET client_min_messages=INFO;
\set ECHO all   
\unset QUIET
\pset tuples_only on
\pset recordsep '\n\n=======\n'
Record separator is "

=======
".
\echo  ###### format conversion tests
###### format conversion tests
-- ===== Setup Test Environment =====
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    address_id INT NOT NULL,
    email VARCHAR(150),
    phone_number VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE
create index customers_idx on customers(last_name);
CREATE INDEX
CREATE TABLE regions (
    region_id SERIAL PRIMARY KEY,
    region_name VARCHAR(100) NOT NULL
);
CREATE TABLE
CREATE TABLE countries (
    country_id SERIAL PRIMARY KEY,
    country_name VARCHAR(100) NOT NULL,
    region_id INT NOT NULL,
    FOREIGN KEY (region_id) REFERENCES regions(region_id)
);
CREATE TABLE
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    product_description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock_quantity INT NOT NULL
);
CREATE TABLE
CREATE TABLE branches (
    branch_id SERIAL PRIMARY KEY,
    branch_name VARCHAR(150) NOT NULL,
    branch_location VARCHAR(200)
);
CREATE TABLE
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(150) NOT NULL,
    branch_id INT NOT NULL,
    position VARCHAR(100),
    hire_date DATE NOT NULL,
    FOREIGN KEY (branch_id) REFERENCES branches(branch_id)
);
CREATE TABLE
CREATE TABLE orders (
    order_id SERIAL,
    customer_id INT NOT NULL,
    employee_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
    PRIMARY KEY (order_date,order_id)
) PARTITION BY RANGE (order_date);
CREATE TABLE
create index order_id_idx on orders(order_id);
CREATE INDEX
DO $$
DECLARE
    i INT;
BEGIN
    FOR i IN 0..19 LOOP
        EXECUTE format('CREATE TABLE orders_p%s PARTITION OF orders FOR VALUES FROM (%L) TO (%L)', 
            i, CURRENT_DATE - i, CURRENT_DATE - i + 1);
    END LOOP;
    CREATE TABLE orders_default PARTITION OF orders DEFAULT;
END $$;
DO
CREATE TABLE order_details (
    order_detail_id SERIAL,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    PRIMARY KEY (order_detail_id, order_id)
) PARTITION BY HASH (order_id);
CREATE TABLE
CREATE TABLE order_details_p0 PARTITION OF order_details FOR VALUES WITH (MODULUS 5, REMAINDER 0);
CREATE TABLE
CREATE TABLE order_details_p1 PARTITION OF order_details FOR VALUES WITH (MODULUS 5, REMAINDER 1);
CREATE TABLE
CREATE TABLE order_details_p2 PARTITION OF order_details FOR VALUES WITH (MODULUS 5, REMAINDER 2);
CREATE TABLE
CREATE TABLE order_details_p3 PARTITION OF order_details FOR VALUES WITH (MODULUS 5, REMAINDER 3);
CREATE TABLE
CREATE TABLE order_details_p4 PARTITION OF order_details FOR VALUES WITH (MODULUS 5, REMAINDER 4);
CREATE TABLE
CREATE TABLE payments (
    payment_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL,
    payment_date DATE NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    payment_method VARCHAR(50)
);
CREATE TABLE
CREATE TABLE addresses (
    address_id SERIAL PRIMARY KEY,
    street_address VARCHAR(200) NOT NULL,
    city VARCHAR(100) NOT NULL,
    state VARCHAR(100),
    country_id INT NOT NULL,
    postal_code VARCHAR(20),
    FOREIGN KEY (country_id) REFERENCES countries(country_id)
);
CREATE TABLE
-- ===== Insert Sample Data =====
INSERT INTO regions (region_name) SELECT 'Region_' || i FROM GENERATE_SERIES(1, 10) AS i; -- 10 regions;
INSERT 0 10
INSERT INTO countries (country_name, region_id)  SELECT 'Country_' || i, CEIL(RANDOM() * 10)
FROM GENERATE_SERIES(1, 100) AS i; -- 100 countries, random regions
INSERT 0 100
INSERT INTO addresses (street_address, city, state, country_id, postal_code)
SELECT
    'Street_' || i,
    'City_' || CEIL(RANDOM() * 1000),
    'State_' || CEIL(RANDOM() * 50),
    CEIL(RANDOM() * 100),
    '10000' || i
FROM GENERATE_SERIES(1, 1000) AS i; -- 1000 addresses
INSERT 0 1000
INSERT INTO branches (branch_name, branch_location)
SELECT
    'Branch_' || i,
    'Location_' || CEIL(RANDOM() * 100)
FROM GENERATE_SERIES(1, 50) AS i; -- 50 branches
INSERT 0 50
INSERT INTO employees (employee_name, branch_id, position, hire_date)
SELECT
    'Employee_' || i,
    CEIL(RANDOM() * 50),
    'Position_' || CEIL(RANDOM() * 10),
    CURRENT_DATE - INTERVAL '1 day' * FLOOR(RANDOM() * 365 * 5) -- Random hire date in the past 5 years
FROM GENERATE_SERIES(1, 500) AS i; -- 500 employees
INSERT 0 500
INSERT INTO customers (first_name, last_name, address_id, email, phone_number, created_at)
SELECT
    'FirstName' || i,
    'LastName' || i,
    CEIL(RANDOM() * 1000), -- Random address_id
    'customer' || i || '@example.com',
    '123-456-7890',
    CURRENT_DATE - INTERVAL '1 day' * FLOOR(RANDOM() * 365 * 2) -- Random creation date in the past 2 years
FROM GENERATE_SERIES(1, 1000) AS i;
INSERT 0 1000
INSERT INTO orders (customer_id, employee_id, order_date, total_amount)
SELECT
    CEIL(RANDOM() * 1000), -- Random customer_id
    CEIL(RANDOM() * 500), -- Random employee_id
    CURRENT_DATE - INTERVAL '1 day' * FLOOR(RANDOM() * 365 * 2), -- Random order date
    CEIL(RANDOM() * 1000 + 10) -- Random total amount between $10 and $1010
FROM GENERATE_SERIES(1, 100) AS i;
INSERT 0 100
INSERT INTO products (product_name, product_description, price, stock_quantity)
SELECT
    'Product_' || i,
    'Description for product ' || i,
    CEIL(RANDOM() * 100), -- Price between $1 and $101
    CEIL(RANDOM() * 1000) -- Stock quantity between 1 and 1000
FROM GENERATE_SERIES(1, 500) AS i; -- 500 products
INSERT 0 500
-- 9. Insert data into order_details
INSERT INTO order_details (order_id, product_id, quantity, price)
SELECT
    CEIL(RANDOM() * 100), -- Random order_id
    CEIL(RANDOM() * 500), -- Random product_id
    CEIL(RANDOM() * 10), -- Quantity between 1 and 10
    CEIL(RANDOM() * 100 + 1) -- Price between $1 and $101
FROM GENERATE_SERIES(1, 50000) AS i; -- 50,000 order details
INSERT 0 50000
INSERT INTO payments (order_id, payment_date, amount, payment_method)
SELECT
    CEIL(RANDOM() * 100), -- Random order_id
    CURRENT_DATE - INTERVAL '1 day' * FLOOR(RANDOM() * 365 * 2), -- Random payment date
    CEIL(RANDOM() * 1000 + 10), -- Amount between $10 and $1010
    CASE WHEN RANDOM() < 0.5 THEN 'Credit Card' ELSE 'PayPal' END -- Random payment method
FROM GENERATE_SERIES(1, 10000) AS i; -- 10,000 payments
INSERT 0 10000
 \pset pager off
Pager usage is off.
-- Planner settings to force certain plan types for testing
-- SET enable_seqscan = OFF;
-- SET enable_indexscan = OFF;
-- SET enable_bitmapscan = OFF;
-- SET enable_tidscan = OFF;
-- SET enable_sort = OFF;
-- SET enable_hashagg = OFF;
-- SET enable_nestloop = OFF;
-- SET enable_mergejoin = OFF;
-- SET enable_hashjoin = OFF;
select pg_store_plans_reset();
 

\o /dev/null
-- ===== Test Queries =====
PREPARE my_regions (text) AS SELECT region_name, region_id FROM regions WHERE region_name = $1;
EXECUTE my_regions('Region_1');
EXECUTE my_regions('Region_2');
DEALLOCATE my_regions;
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     2 | Seq Scan on regions  (cost=0.00..14.00 rows=2 width=222)+
       |   Filter: ((region_name)::text = 'Region_1'::text)

select pg_store_plans_reset();
 

\o /dev/null
SELECT e.employee_name, e.position, b.branch_name
FROM employees e
JOIN branches b ON e.branch_id = b.branch_id
WHERE b.branch_name in ('Branch_2','Branch_3','Branch_5');
SELECT e.employee_name, e.position, b.branch_name
FROM employees e
JOIN branches b ON e.branch_id = b.branch_id
WHERE b.branch_name in ('Branch_10','Branch_1');
\g
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Hash Join  (cost=11.41..23.19 rows=4 width=854)                                           +
       |   Hash Cond: (e.branch_id = b.branch_id)                                                  +
       |   ->  Seq Scan on employees e  (cost=0.00..11.40 rows=140 width=540)                      +
       |   ->  Hash  (cost=11.38..11.38 rows=3 width=322)                                          +
       |         ->  Seq Scan on branches b  (cost=0.00..11.38 rows=3 width=322)                   +
       |               Filter: ((branch_name)::text = ANY ('{Branch_2,Branch_3,Branch_5}'::text[]))
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     2 | Hash Join  (cost=11.28..23.05 rows=3 width=854)                                           +
       |   Hash Cond: (e.branch_id = b.branch_id)                                                  +
       |   ->  Seq Scan on employees e  (cost=0.00..11.40 rows=140 width=540)                      +
       |   ->  Hash  (cost=11.25..11.25 rows=2 width=322)                                          +
       |         ->  Seq Scan on branches b  (cost=0.00..11.25 rows=2 width=322)                   +
       |               Filter: ((branch_name)::text = ANY ('{Branch_10,Branch_1}'::text[]))

select pg_store_plans_reset();
 

\o /dev/null
SELECT e.employee_name, e.position, b.branch_name
FROM employees e
JOIN branches b ON e.branch_id = b.branch_id
WHERE b.branch_name in ('Branch_10','Branch_1');
SET enable_hashjoin = OFF;
SELECT e.employee_name, e.position, b.branch_name
FROM employees e
JOIN branches b ON e.branch_id = b.branch_id
WHERE b.branch_name in ('Branch_10','Branch_1');
\g
SET enable_nestloop = OFF;
SELECT e.employee_name, e.position, b.branch_name
FROM employees e
JOIN branches b ON e.branch_id = b.branch_id
WHERE b.branch_name in ('Branch_10','Branch_1');
\g
\g
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Hash Join  (cost=11.28..23.05 rows=3 width=854)                                   +
       |   Hash Cond: (e.branch_id = b.branch_id)                                          +
       |   ->  Seq Scan on employees e  (cost=0.00..11.40 rows=140 width=540)              +
       |   ->  Hash  (cost=11.25..11.25 rows=2 width=322)                                  +
       |         ->  Seq Scan on branches b  (cost=0.00..11.25 rows=2 width=322)           +
       |               Filter: ((branch_name)::text = ANY ('{Branch_10,Branch_1}'::text[]))
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     2 | Nested Loop  (cost=0.00..26.85 rows=3 width=854)                                  +
       |   Join Filter: (b.branch_id = e.branch_id)                                        +
       |   ->  Seq Scan on employees e  (cost=0.00..11.40 rows=140 width=540)              +
       |   ->  Materialize  (cost=0.00..11.26 rows=2 width=322)                            +
       |         ->  Seq Scan on branches b  (cost=0.00..11.25 rows=2 width=322)           +
       |               Filter: ((branch_name)::text = ANY ('{Branch_10,Branch_1}'::text[]))
     3 | Merge Join  (cost=27.65..28.38 rows=3 width=854)                                  +
       |   Merge Cond: (e.branch_id = b.branch_id)                                         +
       |   ->  Sort  (cost=16.39..16.74 rows=140 width=540)                                +
       |         Sort Key: e.branch_id                                                     +
       |         ->  Seq Scan on employees e  (cost=0.00..11.40 rows=140 width=540)        +
       |   ->  Sort  (cost=11.26..11.27 rows=2 width=322)                                  +
       |         Sort Key: b.branch_id                                                     +
       |         ->  Seq Scan on branches b  (cost=0.00..11.25 rows=2 width=322)           +
       |               Filter: ((branch_name)::text = ANY ('{Branch_10,Branch_1}'::text[]))

select pg_store_plans_reset();
 

\o /dev/null
select last_name from customers where last_name='customer128' or last_name='custom123';
select last_name from customers where last_name='customer128';
select last_name from customers where last_name>='customer1';
SET enable_seqscan = OFF;
select last_name from customers where last_name>='customer1';
select last_name from customers where last_name='custom123';
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
select last_name from customers where last_name='custom123';
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Bitmap Heap Scan on customers  (cost=12.62..28.18 rows=45 width=218)                                  +
       |   Recheck Cond: ((last_name)::text >= 'customer1'::text)                                              +
       |   ->  Bitmap Index Scan using customers_idx  (cost=0.00..12.61 rows=45 width=0)                       +
       |         Index Cond: ((last_name)::text >= 'customer1'::text)
     1 | Bitmap Heap Scan on customers  (cost=4.28..8.29 rows=1 width=218)                                     +
       |   Recheck Cond: ((last_name)::text = 'custom123'::text)                                               +
       |   ->  Bitmap Index Scan using customers_idx  (cost=0.00..4.28 rows=1 width=0)                         +
       |         Index Cond: ((last_name)::text = 'custom123'::text)
     1 | Bitmap Heap Scan on customers  (cost=8.56..14.40 rows=2 width=218)                                    +
       |   Recheck Cond: (((last_name)::text = 'customer128'::text) OR ((last_name)::text = 'custom123'::text))+
       |   ->  BitmapOr  (cost=8.56..8.56 rows=2 width=0)                                                      +
       |         ->  Bitmap Index Scan using customers_idx  (cost=0.00..4.28 rows=1 width=0)                   +
       |               Index Cond: ((last_name)::text = 'customer128'::text)                                   +
       |         ->  Bitmap Index Scan using customers_idx  (cost=0.00..4.28 rows=1 width=0)                   +
       |               Index Cond: ((last_name)::text = 'custom123'::text)
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     1 | Seq Scan on customers  (cost=0.00..16.69 rows=45 width=218)                                           +
       |   Filter: ((last_name)::text >= 'customer1'::text)
     2 | Index Only Scan using customers_idx on customers  (cost=0.27..8.29 rows=1 width=218)                  +
       |   Index Cond: (last_name = 'customer128'::text)

select pg_store_plans_reset();
 

\o /dev/null
SELECT employee_name, branch_id, hire_date,
    rank() OVER (PARTITION BY branch_id ORDER BY hire_date)
FROM employees;
SELECT employee_name, branch_id, hire_date,
    rank() OVER (PARTITION BY employee_name ORDER BY hire_date)
FROM employees;
SELECT employee_name, branch_id, hire_date,
    rank() OVER (PARTITION BY employee_name)
FROM employees;
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     1 | WindowAgg  (cost=16.39..18.84 rows=140 width=334)                       +
       |   ->  Sort  (cost=16.39..16.74 rows=140 width=326)                      +
       |         Sort Key: employee_name                                         +
       |         ->  Seq Scan on employees  (cost=0.00..11.40 rows=140 width=326)
     1 | WindowAgg  (cost=16.39..19.19 rows=140 width=334)                       +
       |   ->  Sort  (cost=16.39..16.74 rows=140 width=326)                      +
       |         Sort Key: branch_id, hire_date                                  +
       |         ->  Seq Scan on employees  (cost=0.00..11.40 rows=140 width=326)
     1 | WindowAgg  (cost=16.39..19.19 rows=140 width=334)                       +
       |   ->  Sort  (cost=16.39..16.74 rows=140 width=326)                      +
       |         Sort Key: employee_name, hire_date                              +
       |         ->  Seq Scan on employees  (cost=0.00..11.40 rows=140 width=326)

select pg_store_plans_reset();
 

\o /dev/null
WITH min_customer AS (
     -- Find and return the customer with the minimum customer_id
     SELECT MIN(customer_id) AS customer_id
     FROM customers
)
DELETE FROM payments
WHERE order_id IN (
    SELECT order_id
    FROM orders
    WHERE order_date > current_date - 10 and customer_id = (SELECT customer_id FROM min_customer)
);
WITH min_customer AS (
     -- Find and return the customer with the minimum customer_id
     SELECT MIN(customer_id) AS customer_id
     FROM customers
)
DELETE FROM payments
WHERE order_id IN (
    SELECT order_id
    FROM orders
    WHERE order_date > current_date - 20 and customer_id = (SELECT customer_id FROM min_customer)
);
\o
select calls, plan from pg_store_plans order by calls, plan;
     1 | Result  (cost=0.00..0.01 rows=1 width=4)
     2 | Delete on payments  (cost=862.31..885.06 rows=0 width=0)                                                     +
       |   InitPlan 1                                                                                                 +
       |     ->  Aggregate  (cost=16.69..16.70 rows=1 width=4)                                                        +
       |         ->  Seq Scan on customers  (cost=0.00..16.35 rows=135 width=4)                                       +
       |   ->  Merge Semi Join  (cost=845.61..868.36 rows=667 width=16)                                               +
       |         Merge Cond: (payments.order_id = orders.order_id)                                                    +
       |         ->  Sort  (cost=285.34..293.28 rows=3174 width=10)                                                   +
       |               Sort Key: payments.order_id                                                                    +
       |               ->  Seq Scan on payments  (cost=0.00..100.74 rows=3174 width=10)                               +
       |         ->  Sort  (cost=560.27..560.37 rows=42 width=14)                                                     +
       |               Sort Key: orders.order_id                                                                      +
       |               ->  Append  (cost=7.56..559.14 rows=42 width=14)                                               +
       |                     Subplans Removed: 9                                                                      +
       |                     ->  Bitmap Heap Scan on orders_p10 orders_1  (cost=7.56..26.62 rows=2 width=14)          +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p10_pkey  (cost=0.00..7.55 rows=453 width=0)    +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p9 orders_2  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p9_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p8 orders_3  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p8_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p7 orders_4  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p7_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p6 orders_5  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p6_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p5 orders_6  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p5_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p4 orders_7  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p4_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p3 orders_8  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p3_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p2 orders_9  (cost=7.56..26.62 rows=2 width=14)           +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p2_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p1 orders_10  (cost=7.56..26.62 rows=2 width=14)          +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p1_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_p0 orders_11  (cost=7.56..26.62 rows=2 width=14)          +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_p0_pkey  (cost=0.00..7.55 rows=453 width=0)     +
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))                               +
       |                     ->  Bitmap Heap Scan on orders_default orders_12  (cost=7.56..26.62 rows=2 width=14)     +
       |                           Recheck Cond: (order_date > (CURRENT_DATE - 10))                                   +
       |                           Filter: (customer_id = (InitPlan 1).col1)                                          +
       |                           ->  Bitmap Index Scan using orders_default_pkey  (cost=0.00..7.55 rows=453 width=0)+
       |                                 Index Cond: (order_date > (CURRENT_DATE - 10))

select pg_store_plans_reset();
 

\o /dev/null
drop TABLE addresses;
drop TABLE payments;
drop TABLE order_details;
drop TABLE orders;
drop TABLE employees;
drop TABLE branches;
drop TABLE products;
drop TABLE customers;
drop TABLE countries;
drop TABLE regions;
